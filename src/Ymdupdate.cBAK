

#include <assert.h>
#include "Yproto.h"



/* 闭环第一刀：在 cutSlot 与其下一槽位之间断开，形成开链
   - 断点：i2elnext[g][cutSlot] = -1
   - 链头：原 cutSlot 的下一个槽位（断口后成为 head）
   - 约定：保持其余 next 不变
*/
static void break_closed_loop_into_open_chain(YINT* i1elcount, YINT* i1head, YINT** i2elnext, YINT g, YINT cutSlot) {
    YINT count = i1elcount[g];
    if (count <= 0) return;
    assert(cutSlot >= 0 && cutSlot < count);

    // 记录断口后的新 head：原 cutSlot 的 next
    YINT nextOfCut = i2elnext[g][cutSlot];
    // 防御：闭环应当存在合法 next
    assert(nextOfCut >= 0 && nextOfCut < count);

    // 真正断环：尾部是 cutSlot，尾的 next = -1
    i2elnext[g][cutSlot] = -1;

    // 设定链头：断口之后的第一个槽位即 head
    i1head[g] = nextOfCut;

    // 注意：其他槽位的 next 保持原状（依旧顺时针连接），只是在 cut 处断开。
}


/* --------- 小工具：在组内查槽位（线性扫描，跳过-1槽位） --------- */
static inline YINT find_slot_in_group(YINT* i1elcount,YINT** i2elno, YINT g, YINT node) {
    YINT count = i1elcount[g];
    for (YINT s = 0; s < count; ++s) {
        if (i2elno[g][s] == node) return s;
    }
    return -1;
}

/* --------- 小工具：建立开链的线性序 order_in_chain，返回可达槽位数 --------- */
static YINT build_order_in_chain(YINT* i1elcount,YINT* i1head,YINT** i2elnext, YINT g, YINT *order_in_chain /*size>=count*/) {
    YINT count = i1elcount[g];
    for (YINT s = 0; s < count; ++s) order_in_chain[s] = -1;

    YINT head = i1head[g];
    if (head < 0) return 0;

    YINT ord = 0;
    YINT cur = head;
    while (cur != -1) {
        order_in_chain[cur] = ord++;
        YINT nxt = i2elnext[g][cur];
        if (nxt == -1) break;           // 开链尾
        cur = nxt;
        // 防御：避免异常环
        if (ord > count) break;
    }
    return ord; // 实际线性长度
}

/* --------- 工具：加入 cuts 去重（简单线性去重，k通常很小） --------- */
static inline void add_cut_unique(YINT *cuts, YINT *k, YINT slot) {
    for (YINT i = 0; i < *k; ++i) if (cuts[i] == slot) return;
    cuts[(*k)++] = slot;
}

/* --------- 工具：判断组是否开链 --------- */
static inline int is_open_chain(YINT* i1boundaryflag, YINT g) {
    return i1boundaryflag[g] == 1;
}

/* --------- 闭环：按环顺时针对 cuts 排序（从任一cuts起始，顺着next捕获其余cut） --------- */
static void sort_cuts_on_loop(YINT* i1elcount,  YINT** i2elnext,  YINT g, const YINT *cuts, YINT k, YINT *out_sorted /*size k*/) {
    // 标记表：slot -> isCut
    YINT count = i1elcount[g];
    char *isCut = (char*)malloc((size_t)count);
    memset(isCut, 0, (size_t)count);
    for (YINT i = 0; i < k; ++i) {
        YINT s = cuts[i];
        if (s >= 0 && s < count) isCut[s] = 1;
    }

    // 从第一个cut出发，环上顺时针扫描，依次收集
    YINT idx = 0;
    YINT start = cuts[0];
    YINT cur = start;
    do {
        if (isCut[cur]) {
            out_sorted[idx++] = cur;
            if (idx == k) break;
            isCut[cur] = 0; // 清掉，防重复
        }
        cur = i2elnext[g][cur];
        // 防御：异常结构避免死循环
        if (cur < 0 || cur >= count) break;
    } while (cur != start);

    // 如果没有完整收集，退化为原 cuts（保证不崩）
    if (idx != k) {
        memcpy(out_sorted, cuts, (size_t)k * sizeof(YINT));
    }
    free(isCut);
}

/* --------- 开链：按 order_in_chain 升序排 cuts --------- */
static void sort_cuts_on_open_chain(const YINT *order_in_chain, const YINT *cuts, YINT k, YINT *out_sorted) {
    // 简单插入排序（k很小，足够快）
    for (YINT i = 0; i < k; ++i) out_sorted[i] = cuts[i];
    for (YINT i = 1; i < k; ++i) {
        YINT key = out_sorted[i];
        YINT j = i - 1;
        while (j >= 0 && order_in_chain[out_sorted[j]] > order_in_chain[key]) {
            out_sorted[j + 1] = out_sorted[j];
            --j;
        }
        out_sorted[j + 1] = key;
    }
}

/* --------- 开链：根据 cuts 分段并赋 master（只改 i1getmaster） --------- */
static void update_master_open_chain(YINT* i1elcount,YINT* i1head,YINT** i2elnext,YINT** i2elno, YINT* i1getmaster,YINT g, const YINT *cuts, YINT k) {
    YINT count = i1elcount[g];
    if (count <= 0) return;

    // 建线性序
    YINT *order_in_chain = (YINT*)malloc((size_t)count * sizeof(YINT));
    YINT nlin = build_order_in_chain(i1elcount,i1head,i2elnext, g, order_in_chain);
    (void)nlin; // 可用于一致性检查

    // 排序 cuts
    YINT *sorted = (YINT*)malloc((size_t)k * sizeof(YINT));
    sort_cuts_on_open_chain(order_in_chain, cuts, k, sorted);

    // 段首序列：head, cut1, cut2, ..., cutK
    YINT head = i1head[g];
    assert(head >= 0);

    // 段0：head -> cut1 之前
    YINT segHeadSlot = head;
    YINT segHeadNode = i2elno[g][segHeadSlot];
    if (segHeadNode >= 0) i1getmaster[segHeadNode] = segHeadNode;

    YINT cur = head;
    YINT stop = (k > 0) ? sorted[0] : -1;
    while (cur != stop && cur != -1) {
        YINT nid = i2elno[g][cur];
        if (nid >= 0) i1getmaster[nid] = segHeadNode;
        cur = i2elnext[g][cur];
    }

    // 段 i：cuti -> cut(i+1) 之前
    for (YINT i = 0; i < k; ++i) {
        segHeadSlot = sorted[i];
        segHeadNode = i2elno[g][segHeadSlot];
        if (segHeadNode >= 0) i1getmaster[segHeadNode] = segHeadNode;

        cur = segHeadSlot;
        YINT nextStop = (i + 1 < k) ? sorted[i + 1] : -1; // 最后一段到链尾（-1）
        // 跳过段首自身，因为它已自指
        cur = i2elnext[g][cur];
        while (cur != nextStop && cur != -1) {
            YINT nid = i2elno[g][cur];
            if (nid >= 0) i1getmaster[nid] = segHeadNode;
            cur = i2elnext[g][cur];
        }
    }

    free(sorted);
    free(order_in_chain);
}

/* --------- 闭环：第一刀（K=1且历史无切口）不切环，整组换 master --------- */
static void update_master_closed_loop_first_cut_whole_group(YINT* i1elcount, YINT** i2elno, YINT* i1getmaster, YINT g, YINT cutSlot) {
    YINT count = i1elcount[g];
    if (count <= 0) return;
    YINT new_master = i2elno[g][cutSlot];
    assert(new_master >= 0);
    i1getmaster[new_master] = new_master;
    for (YINT s = 0; s < count; ++s) {
        YINT nid = i2elno[g][s];
        if (nid >= 0) i1getmaster[nid] = new_master;
    }
}

/* --------- 闭环：多刀（或已有历史刀）——按环 cuts 分段并赋 master --------- */
static void update_master_closed_loop_multi_cuts(YINT* i1elcount,YINT** i2elno, YINT** i2elnext, YINT* i1getmaster,YINT g, const YINT *cuts, YINT k) {
    YINT count = i1elcount[g];
    if (count <= 0) return;
    if (k <= 0) return;

    YINT *sorted = (YINT*)malloc((size_t)k * sizeof(YINT));
    sort_cuts_on_loop(i1elcount, i2elnext, g, cuts, k, sorted);

    // 对每个段：从 ci 开始，走到 c(i+1) 前（cK 的下一个是 c1，允许回绕）
    for (YINT i = 0; i < k; ++i) {
        YINT segHeadSlot = sorted[i];
        YINT segStopSlot = sorted[(i + 1) % k];

        YINT segHeadNode = i2elno[g][segHeadSlot];
        if (segHeadNode >= 0) i1getmaster[segHeadNode] = segHeadNode;

        YINT cur = segHeadSlot;
        // 跳过段首自身
        cur = i2elnext[g][cur];

        while (cur != segStopSlot) {
            YINT nid = i2elno[g][cur];
            if (nid >= 0) i1getmaster[nid] = segHeadNode;
            cur = i2elnext[g][cur];
            // 防御：避免异常死循环
            if (cur < 0 || cur >= count) break;
        }
    }
    free(sorted);
}











// 结构体用于存储三角形索引和对应的预计算角度
typedef struct {
  YINT ielem;
  double clockwise_angle;
} TriAngle;

// 归并排序函数
void merge(TriAngle *arr, int l, int m, int r) {
  int n1 = m - l + 1;
  int n2 = r - m;

  TriAngle *L = malloc(n1 * sizeof(TriAngle));
  TriAngle *R = malloc(n2 * sizeof(TriAngle));

  for (int i = 0; i < n1; i++)
      L[i] = arr[l + i];
  for (int j = 0; j < n2; j++)
      R[j] = arr[m + 1 + j];

  int i = 0, j = 0, k = l;
  while (i < n1 && j < n2) {
      if (L[i].clockwise_angle <= R[j].clockwise_angle) {
          arr[k++] = L[i++];
      } else {
          arr[k++] = R[j++];
      }
  }

  while (i < n1) arr[k++] = L[i++];
  while (j < n2) arr[k++] = R[j++];

  free(L);
  free(R);
}

void merge_sort(TriAngle *arr, int l, int r) {
  if (l < r) {
      int m = l + (r - l) / 2;
      merge_sort(arr, l, m);
      merge_sort(arr, m + 1, r);
      merge(arr, l, m, r);
  }
}


/*********************PUBLIC********************************************************/
void Ymdupdate(   ydc, yde, ydi, ydn,ydmn, ydpe, ydpn, ydpm, ydfn , ydpj   /***  mesh elements  ***/
        )
  YDC ydc; YDE yde; YDI ydi;  YDN ydn;YDMN ydmn; YDPE ydpe; YDPN ydpn; YDPM ydpm; YDFN ydfn;YDPJ ydpj;
{ YINT nelest, nnopst;
  YINT iprop;
  YINT elprflag;
  YINT icom, i,j, ielem, irow;
  YINT inopo,jprop;
 
  YINT i0, i1, i2,u, i3;

if (ydc->iuptrimesh == 1||ydc->ncstep == 0)
  {

    if(ydpj->npjset>0&&ydc->iuptrimesh == 1)
    { 
      for(ielem=0;ielem<yde->melem;ielem++)
      { if(yde->i1elpr[ielem]>=ydpe->nprop&&yde->d1elfs[ielem]==0)  /* joints   */
        { jprop=yde->i1elpr[ielem]-ydpe->nprop;
          if((ydpj->i1ptyp[jprop])==(YTE2JOINTS))
          { if(ydpj->d1pjfs[jprop]>R0)
            { yde->d1elfs[ielem]=ydpj->d1pjfs[jprop];
            }
            else
            { yde->d1elfs[ielem]=ydpj->d1pjco[jprop];  
        } } }
 } } 


if(ydmn->i2elno==INT2NULL)
  { ydmn->i2elno=TalINT2(ydmn->mnopo,50);
    ydmn->i2elsort=TalINT2(ydmn->mnopo,50);
    ydmn->i2elnext = TalINT2(ydmn->mnopo, 50); // 新增链表指针数组
    ydmn->i1head = TalINT1(ydmn->mnopo);       // 新增链表头指针
    ydmn->i1boundaryflag = TalINT1(ydmn->mnopo); // 新增边界标志数组
    ydmn->i1elcount=TalINT1(ydmn->mnopo);

    }


    for (i=0;i<ydmn->mnopo;i++)

    {ydmn->i1boundaryflag[i] = -1;
      ydmn->i1head[i] = -1; // 初始链表头为 -1 (空链表)
      ydmn->i1elcount[i]=0;
      for(j=0; j<50; j++)
      { ydmn->i2elno[i][j]=-1;
        ydmn->i2elsort[i][j]=-1;
        ydmn->i2elnext[i][j] = -1; // 初始化为 -1 (无后继)

    } }
  


//找到主节点连接的所有三角形
    for(int ielem=0;ielem<yde->nelem;ielem++)
    { if (yde->i2elto[3][ielem]<0 &&yde->i1elpr[ielem]<1e8)
      {
      yde->d2centroid[0][ielem] = (ydn->d2ncc[0][yde->i2elto[0][ielem]] + ydn->d2ncc[0][yde->i2elto[1][ielem]] + ydn->d2ncc[0][yde->i2elto[2][ielem]]) / 3.0;
      yde->d2centroid[1][ielem] = (ydn->d2ncc[1][yde->i2elto[0][ielem]] + ydn->d2ncc[1][yde->i2elto[1][ielem]] + ydn->d2ncc[1][yde->i2elto[2][ielem]]) / 3.0;
       for(int i=0;i<3;i++)
         {
           ydmn->i2elsort[ydn->i1getmasterfem[yde->i2elto[i][ielem]]][ydmn->i1elcount[ydn->i1getmasterfem[yde->i2elto[i][ielem]]]] = ielem;
           ydmn->i1elcount[ydn->i1getmasterfem[yde->i2elto[i][ielem]]]++;
         }
    }


  }

for (int i = 0; i < ydmn->nnopo; i++) 
{
    if (ydmn->i1elcount[i] > 0) 
    {
        YINT count = ydmn->i1elcount[i]; // 实际相邻单元数
        TriAngle *tri_angles = malloc(count * sizeof(TriAngle));

        DBL x0 = ydmn->d2ncc[0][i];
        DBL y0 = ydmn->d2ncc[1][i];

        // 1. 计算每个单元的相对角度
        for (int t = 0; t < count; t++) {
            YINT ielem = ydmn->i2elsort[i][t];
            DBL dx = yde->d2centroid[0][ielem] - x0;
            DBL dy = yde->d2centroid[1][ielem] - y0;
            double angle = atan2(dy, dx);
            if (angle < 0) angle += 2 * MYPI;
            tri_angles[t].clockwise_angle = fmod(2 * MYPI - (angle - (MYPI * 0.5)), 2 * MYPI);
            tri_angles[t].ielem = ielem;
        }

        // 2. 归并排序
        merge_sort(tri_angles, 0, count - 1);

        // 3. 更新排序后的单元列表
        for (int t = 0; t < count; t++) {
            ydmn->i2elsort[i][t] = tri_angles[t].ielem;
        }



        // 5. 设置链表头
        ydmn->i1head[i] = 0; // 以第一个单元为头节点

        free(tri_angles);

 // 4. 构建链表（闭环或单节点开链）
if (count == 1) {
    // 单节点开链
    ydmn->i2elnext[i][0] = -1;   // 没有下一个槽位
    ydmn->i1head[i]      = 0;    // 唯一槽位作为链头
} else {
    // 闭环
    for (int t = 0; t < count; t++) {
        ydmn->i2elnext[i][t] = (t == count - 1) ? 0 : t + 1;
    }
    ydmn->i1head[i] = 0;         // 闭环时起点随意
}

// 6. 第一遍：填 i2elno（每个槽位对应的 detached node）
for (int t = 0; t < count; t++) {
    ydmn->i2elno[i][t] = -1; // 默认无节点
    int elem = ydmn->i2elsort[i][t];
    for (int e = 0; e < 3; e++) {
        int nid = yde->i2elto[e][elem];
        if (nid >= 0 && ydn->i1getmasterfem[nid] == i) {
            ydmn->i2elno[i][t] = nid;
            break; // 找到一个就够
        }
    }
}

// 7. 第二遍：选择 master 并赋值
int master = -1;
for (int t = 0; t < count; t++) {
    int nid = ydmn->i2elno[i][t];
    if (nid >= 0) { master = nid; break; }
}
if (master >= 0) {
    ydn->i1getmaster[master] = master; // master 自指
    for (int t = 0; t < count; t++) {
        int nid = ydmn->i2elno[i][t];
        if (nid >= 0) {
            ydn->i1getmaster[nid] = master;
        }
    }
}

    }
ydmn->i1boundaryflag[i] = 0;
}








// 说明：本段用于将“闭环的元素索引链”在边界组（恰有两个边界端点）情况下重建为“开链”。
// 策略：先用“最大角缺口法”定位外侧缺口，得到 head/tail；当几何不确定（wrapGap≈maxGap 或 maxGap 较小）
// 时，回退为“边界端点法”（以两端边界索引 p、q 选较长弧段）。重建只修改 i2elnext 与 i1head，不改变 i2elsort/i2elno。
// Modified: use boundary-endpoint method first; only when two arc lengths are equal fall back to max-gap method
for (int i = 0; i < ydmn->nnopo; i++) {
    int count = ydmn->i1elcount[i];
    if (count <= 0) continue;
    if (count < 2) continue;

    // 统计本组内的“边界端点”数量（通过节点层面的边界标记 i1nobf0）
    int boundaryCount = 0;
    for (int t = 0; t < count; t++) {
        int nodeId = ydmn->i2elno[i][t];
        if (nodeId >= 0 && ydn->i1nobf0[nodeId] == 1) boundaryCount++;
    }

    // 仅当“恰有两个边界端点”时，将原闭环改造为开链；其他情况维持闭环
    if (boundaryCount == 2) {
        // 角度容差与“几何不确定阈值”
        //const double eps = 1e-8;
        //const double threshold = 150.0 * MYPI / 180.0; // 150° 转弧度

        // 先寻找两个边界端点在顺时针序中的位置索引 bpos[0], bpos[1]
        int bpos[2] = { -1, -1 };
        int bcnt = 0;
        for (int t = 0; t < count; t++) {
            int nid = ydmn->i2elno[i][t];
            if (nid >= 0 && ydn->i1nobf0[nid] == 1) {
                if (bcnt < 2) bpos[bcnt] = t;
                bcnt++;
            }
        }

        // Defensive: 若 bcnt 不等于 2（异常），保持原闭环，不做修改
        if (bcnt != 2) {
            continue;
        }

        int p = bpos[0], q = bpos[1];
        if (q < p) { int tmp = p; p = q; q = tmp; }

        // 段 A：p -> ... -> q（不回绕）；长度 = q - p + 1
        // 段 B：q -> ... -> p（跨越首尾回绕）；长度 = (count - q) + (p + 1)
        int lenA = q - p + 1;
        int lenB = (count - q) + (p + 1);

        int headIdx = -1;
        int tailIdx = -1;

        if (lenA != lenB) {
            // 如果两段不等长，直接选择较长段作为开链
            if (lenB > lenA) {
                assert(lenA==2); // 边界端点法下，较短段必为 2
                headIdx = q; // 段 B 起点
                tailIdx = p; // 段 B 终点
            } else {
                 assert(lenB==2); // 边界端点法下，较短段必为 2
                headIdx = p; // 段 A 起点
                tailIdx = q; // 段 A 终点
            }
            // 断言 head/tail 对应边界节点
            int nid_head = ydmn->i2elno[i][headIdx];
            int nid_tail = ydmn->i2elno[i][tailIdx];
            assert(nid_head >= 0 && ydn->i1nobf0[nid_head] == 1);
            assert(nid_tail >= 0 && ydn->i1nobf0[nid_tail] == 1);
        } else {
            // 两段等长：回退为最大角缺口法来决定（与原逻辑类似）
            assert(lenA==2&&lenB==2); 
            // 计算每个相邻单元（按 i2elsort 顺序）的顺时针极角
            double* ang = (double*)malloc(sizeof(double) * count);
            double x0 = ydmn->d2ncc[0][i];
            double y0 = ydmn->d2ncc[1][i];
            for (int t = 0; t < count; t++) {
                int ielem = ydmn->i2elsort[i][t];
                double dx = yde->d2centroid[0][ielem] - x0;
                double dy = yde->d2centroid[1][ielem] - y0;
                double a = atan2(dy, dx);
                if (a < 0) a += 2 * MYPI;
                double cw = fmod(2 * MYPI - (a - (MYPI * 0.5)), 2 * MYPI);
                ang[t] = cw;
            }

            // 在已排序角序 ang[t] 上寻找“最大角缺口”
            int gapIdx = -1;
            double maxGap = -1.0;
            for (int t = 0; t < count - 1; t++) {
                double gap = ang[t+1] - ang[t];
                if (gap > maxGap) { maxGap = gap; gapIdx = t; }
            }
            double wrapGap = (ang[0] + 2 * MYPI) - ang[count - 1];
            if (wrapGap > maxGap) { maxGap = wrapGap; gapIdx = count - 1; }

            // headIdx = 缺口之后的第一个（越过缺口进入覆盖区）
            // tailIdx = 缺口之前的那个（缺口起点）
            headIdx = (gapIdx + 1 == count) ? 0 : (gapIdx + 1);
            tailIdx = gapIdx;

            // 若几何不确定（wrapGap≈maxGap 或 maxGap 较小），仍可接受：
            // 这里我们使用最大缺口法作为最终决策，因为前面两段等长无法区分方向
     

            free(ang);
        }

        // 4) 重建 i2elnext：只保留所选弧段上的顺时针索引链，其余置为 -1，尾部 next = -1
        for (int t = 0; t < count; t++) ydmn->i2elnext[i][t] = -1;
        int cur = headIdx;
        while (cur != tailIdx) {
            int nxt = (cur + 1 == count) ? 0 : (cur + 1);
            ydmn->i2elnext[i][cur] = nxt;
            cur = nxt;
        }
        // tailIdx 的 next 保持 -1

        // 5) 设置本组的链表头位置索引
        ydmn->i1head[i] = headIdx;

        // 额外步骤：开链初始化 master = 链头节点
        int headNode = ydmn->i2elno[i][headIdx];
        if (headNode >= 0) {
            ydn->i1getmaster[headNode] = headNode;
            int slot = headIdx;
            while (slot != -1) {
                int nid = ydmn->i2elno[i][slot];
                if (nid >= 0) { ydn->i1getmaster[nid] = headNode; }
                slot = ydmn->i2elnext[i][slot];
            }
        }

        // 标记为边界组
        ydmn->i1boundaryflag[i] = 1;
    }
    // 若 boundaryCount != 2，则保持第一遍构建的“闭环索引链”（i2elnext 已按环设置，i1head=0）。
}









/* --------- 主流程：一次性处理所有激活 CE4，按组收集cuts并更新 i1getmaster --------- */

    const YINT G = ydmn->nnopo;

    // 组级工作区：cuts（每组最多 count 个）、cut数、seen、historyCuts标记（如需）
    YINT **groupCuts = (YINT**)malloc((size_t)G * sizeof(YINT*));
    YINT *groupK = (YINT*)malloc((size_t)G * sizeof(YINT));
    char *seen = (char*)malloc((size_t)G);
    memset(groupK, 0, (size_t)G * sizeof(YINT));
    memset(seen, 0, (size_t)G);

    for (YINT g = 0; g < G; ++g) {
        YINT cap = ydmn->i1elcount[g] > 0 ? ydmn->i1elcount[g] : 1;
        groupCuts[g] = (YINT*)malloc((size_t)cap * sizeof(YINT));
    }

    // A. 收集：对每条激活CE4，按 i1getmasterfem 判定两侧 (a,b,g)，求“后者槽位”加入 cuts[g]
    for (YINT k = 0; k < yde->nesft; ++k) {
        YINT ielem = yde->i1esft[k];
        YINT n[4] = {
            yde->i2elto[0][ielem],
            yde->i2elto[1][ielem],
            yde->i2elto[2][ielem],
            yde->i2elto[3][ielem]
        };
        YINT g_of[4] = {
            ydn->i1getmasterfem[n[0]],
            ydn->i1getmasterfem[n[1]],
            ydn->i1getmasterfem[n[2]],
            ydn->i1getmasterfem[n[3]]
        };

        // 将4个点按 group 归类，最多两个组。用小数组装 (node,group) 对。
        // 简单办法：枚举所有 pair，挑出同组的两对（去重）。
      //  int pair_used_idx[4] = {0,0,0,0};
        YINT pair_nodeA[2], pair_nodeB[2], pair_group[2];
        YINT pair_cnt = 2;

assert(g_of[0] == g_of[3]);
assert(g_of[1] == g_of[2]);
pair_nodeA[0] = n[1];
pair_nodeB[0] = n[2];
pair_group[0] = g_of[1];  // == g_of[2]

// 配对 (0,3)
pair_nodeA[1] = n[0];
pair_nodeB[1] = n[3];
pair_group[1] = g_of[0];  // == g_of[3]


        for (YINT pi = 0; pi < pair_cnt; ++pi) {
            YINT a = pair_nodeA[pi];
            YINT b = pair_nodeB[pi];
            YINT g = pair_group[pi];

            // 仅当两端节点都被标记为本步切割时才判为有效切口
            if (!(ydn->i1remeshf[a] == 1 && ydn->i1remeshf[b] == 1)) continue;

            // 找槽位
            YINT slotA = find_slot_in_group(ydmn->i1elcount, ydmn->i2elno, g, a);
            YINT slotB = find_slot_in_group(ydmn->i1elcount, ydmn->i2elno, g, b);
            if (slotA < 0 || slotB < 0) continue; // 防御

            YINT cutSlot = -1;
            if (is_open_chain(ydmn->i1boundaryflag, g)) {
                // 开链：按线性序比较
                YINT count = ydmn->i1elcount[g];
                YINT *order_in_chain = (YINT*)malloc((size_t)count * sizeof(YINT));
                (void)build_order_in_chain(ydmn->i1elcount, ydmn->i1head, ydmn->i2elnext, g, order_in_chain);
                YINT ordA = order_in_chain[slotA];
                YINT ordB = order_in_chain[slotB];
                free(order_in_chain);
                if (ordA < 0 || ordB < 0) continue; // 不在链上
                cutSlot = (ordA < ordB) ? slotB : slotA;
            } else {
                // 闭环：从 slotA 沿 next 顺时针，先遇到谁谁为后者
                YINT count = ydmn->i1elcount[g];
                YINT cur = slotA;
                int found = 0;
                for (YINT step = 0; step < count; ++step) {
                    cur = ydmn->i2elnext[g][cur];
                    if (cur == slotB) { cutSlot = slotB; found = 1; break; }
                    if (cur == slotA) break; // 回到起点，结束
                }
                if (!found) {
                    // 若未先遇到B，则B到A的方向意味着A在后
                    cutSlot = slotA;
                }
            }

            add_cut_unique(groupCuts[g], &groupK[g], cutSlot);
            seen[g] = 1;
        }
    }

    // B. 逐组更新 i1getmaster
    for (YINT g = 0; g < G; ++g) {
        if (!seen[g]) continue;
        YINT kcuts = groupK[g];
        if (kcuts <= 0) continue;

        if (is_open_chain(ydmn->i1boundaryflag, g)) {
            // 开链：按线性 cuts 分段
            update_master_open_chain(ydmn->i1elcount,ydmn->i1head,ydmn->i2elnext,ydmn->i2elno,ydn->i1getmaster,g, groupCuts[g], kcuts);
        } else {
            // 闭环：
            // 检查是否为“第一刀策略”场景：历史无切口 + 本步仅1刀。
            // 若需要历史切口持久化，请在外部维护一个 per-group 的 hasHistoryCut[g]。
            // 这里先按“默认无历史”处理第一刀特判；若你有历史，请改成条件判断。
            if (kcuts == 1) {
       // 1) 在 cutSlot 处断环，形成开链
       // YINT cutSlot = groupCuts[g][0];
        //break_closed_loop_into_open_chain(ydmn->i1elcount, ydmn->i1head, ydmn->i2elnext, g, cutSlot);
        //// 2) 开链：按线性 cuts 分段并赋 master（此时 cuts 里只有 cutSlot）
        //update_master_open_chain(ydmn->i1elcount, ydmn->i1head, ydmn->i2elnext, ydmn->i2elno, ydn->i1getmaster, g, groupCuts[g], kcuts);
        update_master_closed_loop_first_cut_whole_group(ydmn->i1elcount,ydmn-> i2elno,ydn-> i1getmaster, g, groupCuts[g][0]);
            } else {
                update_master_closed_loop_multi_cuts(ydmn->i1elcount,ydmn->i2elno,ydmn->i2elnext,ydn->i1getmaster,g, groupCuts[g], kcuts);
            }
        }
    }

    // 释放
    for (YINT g = 0; g < G; ++g) free(groupCuts[g]);
    free(groupCuts);
    free(groupK);
    free(seen);









  /* At time step zero, if a mixed DFN type is used, find and assign crack type to all joint elements belonging to the DFN */
  if(ydc->ncstep == 0) 
  { if(ydfn->iusefn == 3)
    { for(int jprop=0;jprop< ydpj->npjset;jprop++) // Loop over joint elements
      { if((ydpj->i1ptyp[jprop])==(YTE2JOINTS))
        { for(ielem=0;ielem<yde->nelem;ielem++)
          { if(yde->i1elpr[ielem]==(jprop+(ydpe->nprop)))
            // Check if two edge nodes (of the joint element) belong to a DFN crack
       	    {DBL xi_0 = ydn->d2nci[0][yde->i2elto[0][ielem]];  
              DBL yi_0 = ydn->d2nci[1][yde->i2elto[0][ielem]];                
              DBL xi_1 = ydn->d2nci[0][yde->i2elto[1][ielem]];
              DBL yi_1 = ydn->d2nci[1][yde->i2elto[1][ielem]];
	      for(int  s=0; s<ydfn->mdfnfr; s++)
	      { for(int k=0; k<ydfn->mdfnno; k++)
	        { if(ydfn->i2dfnn[k][s] >= 0)  
	          { if(xi_0 == ydn->d2nci[0][ydfn->i2dfnn[k][s]])
	            { if(yi_0 == ydn->d2nci[1][ydfn->i2dfnn[k][s]])
	              { for(int r=0; r<ydfn->mdfnno; r++)
	                { if(ydfn->i2dfnn[r][s] >= 0)
		          { if(xi_1 == ydn->d2nci[0][ydfn->i2dfnn[r][s]])
	                    { if(yi_1 == ydn->d2nci[1][ydfn->i2dfnn[r][s]]) 
	                      { 
                          
                          
                          yde->i1edft[ielem] = ydfn->i1dfft[s]; //! Assign crack type to joint element (1 = broken, 2 = cohesive)
  
  
                        } } } } } } } } } } } } } } 
  

}




} 
ydc->iuptrimesh=0;

}
